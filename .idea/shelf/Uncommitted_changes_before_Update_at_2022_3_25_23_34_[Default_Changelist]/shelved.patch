Index: app/src/main/java/com/pr/perfectrecovery/utils/DataVolatile.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.pr.perfectrecovery.utils\r\n\r\nimport android.util.Log\r\nimport com.pr.perfectrecovery.bean.BaseDataDTO\r\nimport com.pr.perfectrecovery.livedata.StatusLiveData\r\nimport kotlin.math.abs\r\n\r\nclass DataVolatile {\r\n\r\n    companion object {\r\n        /**\r\n         * 初始化按压区间值\r\n         */\r\n        var PR_LOW_VALUE = 45\r\n        var PR_HIGH_VALUE = 60\r\n\r\n        var QY_LOW_VALUE = 35\r\n        var QY_HIGH_VALUE = 50\r\n    }\r\n\r\n    //电量值：  0-100%\r\n    private var VI_Value = 0\r\n\r\n    //距离值：  30-150\r\n    private var L_Value = 0\r\n\r\n    //气压值：  0-2000ml\r\n    private var QY_Value = 0\r\n\r\n    //蓝牙连接状态：   0-断开 1-连接\r\n    private var BLS_Value = 0\r\n\r\n    //USB连接状态: 0-断开 1-连接\r\n    private var ULS_Value = 0\r\n\r\n    //通道打开状态 0-关闭 1-打开\r\n    private var TOS_Value = 0\r\n\r\n    //连接方式  0-蓝牙 1-连接USB\r\n    private var LKS_Value = 0\r\n\r\n    //按压位置正确  0-错误  1-正确\r\n    private var PSR_Value = 0\r\n\r\n    //工作方式：00——休眠   01——工作    02——待机\r\n    private var WS_Value = 0\r\n\r\n    //按压频率：0-200\r\n    private var PF_Value = 0\r\n\r\n    //吹气频率：0-200\r\n    private var CF_Value = 0\r\n\r\n    //按压次数\r\n    private var PR_SUM = 0\r\n\r\n    //吹气次数\r\n    private var QY_SUM = 0\r\n\r\n    //吹气上升或下降标志位\r\n    private var top_flag = 0\r\n\r\n    //按压上升或下降标志位\r\n    private var low_flag = 0\r\n\r\n    private var Qliang = 0\r\n\r\n    private val dataDTO = BaseDataDTO()\r\n\r\n    //是否开始数据传输\r\n    private var isStart = false\r\n\r\n    private var L_valueSet = mutableListOf<Int>()\r\n    private var QY_valueSet = mutableListOf<Int>()\r\n    private var QY_valueSet2 = mutableListOf<Int>()\r\n    private var QY_valueSet3 = mutableListOf<Int>()\r\n    private var pt_valueSet = mutableListOf<Int>()\r\n    private var py_valueSet = mutableListOf<Int>()\r\n\r\n    private var deviceMAC: String? = null\r\n    private var QY_RUN_FLAG = 0\r\n\r\n    /**\r\n     * array 数据列表\r\n     * isClear 清除数据集合\r\n     */\r\n    fun qyMax(): Int {\r\n        var maximum = 0\r\n        for (i in QY_valueSet3.indices) {\r\n            if (maximum < QY_valueSet3[i]) {\r\n                maximum = QY_valueSet3[i]\r\n            }\r\n        }\r\n        QY_valueSet3.clear()\r\n        return maximum\r\n    }\r\n\r\n    /**\r\n     * array 数据列表\r\n     * isClear 清除数据集合\r\n     */\r\n    fun max(isClear: Boolean): Int {\r\n        var maximum = 0\r\n        for (i in QY_valueSet.indices) {\r\n            if (maximum < QY_valueSet[i]) {\r\n                maximum = QY_valueSet[i]\r\n            }\r\n        }\r\n        if (isClear) {\r\n            QY_valueSet.clear()\r\n        }\r\n\r\n        return maximum\r\n    }\r\n\r\n    fun selectMax(L1: Int, L2: Int, L3: Int): Int {\r\n        val value1 = kotlin.math.max(L1, L2)\r\n        val value2 = kotlin.math.max(L2, L3)\r\n        return kotlin.math.max(value1, value2)\r\n    }\r\n\r\n    fun selectMin(L1: Int, L2: Int, L3: Int): Int {\r\n        val value1 = kotlin.math.min(L1, L2)\r\n        val value2 = kotlin.math.min(L2, L3)\r\n        return kotlin.math.min(value1, value2)\r\n    }\r\n\r\n    /**\r\n     * 获取吹气值和\r\n     */\r\n    fun qyValue(): Int {\r\n        var sum = 0\r\n        for (i in QY_valueSet2.indices) {\r\n            sum += i\r\n        }\r\n        QY_valueSet2.clear()\r\n        return sum\r\n    }\r\n\r\n    /**\r\n     * 解析蓝发送的数据\r\n     *\r\n     * @param data\r\n     */\r\n    @Synchronized\r\n    fun parseString(data: String?): BaseDataDTO {\r\n        //System.out.print(DataFormatUtils.getCrc16(DataFormatUtils.hexStr2Bytes(data)));\r\n        if (data != null && data.length == 40) {\r\n            deviceMAC = \"001b${data.substring(24, 28) + data.substring(32, 36)}\"\r\n            //模型状态需先判断\r\n            val state = DataFormatUtils.byteArrayToInt(\r\n                DataFormatUtils.hexStr2Bytes(\r\n                    \"00\" + data.substring(\r\n                        28,\r\n                        30\r\n                    )\r\n                )\r\n            )\r\n            if (state and 1 == 1) {\r\n                BLS_Value = 1\r\n            } else {\r\n                BLS_Value = 0\r\n            }\r\n            if (state and 2 == 2) {\r\n                ULS_Value = 1\r\n            } else {\r\n                ULS_Value = 0\r\n            }\r\n            if (state and 4 == 4) {\r\n                TOS_Value = 1\r\n            } else {\r\n                TOS_Value = 0\r\n            }\r\n            if (state and 8 == 8) {\r\n                LKS_Value = 1\r\n            } else {\r\n                LKS_Value = 0\r\n            }\r\n//            if (state and 16 == 16) {\r\n//                PSR_Value = 1\r\n//            } else {\r\n//                PSR_Value = 0\r\n//            }\r\n            if (state and 8 == 8) {\r\n                PSR_Value = 1\r\n            } else {\r\n                PSR_Value = 0\r\n            }\r\n            //按压距离\r\n            val L_d1 = DataFormatUtils.byteArrayToInt(\r\n                DataFormatUtils.hexStr2Bytes(\r\n                    \"00\" + data.substring(\r\n                        12,\r\n                        14\r\n                    )\r\n                )\r\n            )\r\n            val L_d2 = DataFormatUtils.byteArrayToInt(\r\n                DataFormatUtils.hexStr2Bytes(\r\n                    \"00\" + data.substring(\r\n                        14,\r\n                        16\r\n                    )\r\n                )\r\n            )\r\n            val L_d3 = DataFormatUtils.byteArrayToInt(\r\n                DataFormatUtils.hexStr2Bytes(\r\n                    \"00\" + data.substring(\r\n                        16,\r\n                        18\r\n                    )\r\n                )\r\n            )\r\n\r\n            val QY_d1 = DataFormatUtils.byteArrayToInt(\r\n                DataFormatUtils.hexStr2Bytes(\r\n                    \"00\" + data.substring(\r\n                        18,\r\n                        20\r\n                    )\r\n                )\r\n            )\r\n            val QY_d2 = DataFormatUtils.byteArrayToInt(\r\n                DataFormatUtils.hexStr2Bytes(\r\n                    \"00\" + data.substring(\r\n                        20,\r\n                        22\r\n                    )\r\n                )\r\n            )\r\n            val QY_d3 = DataFormatUtils.byteArrayToInt(\r\n                DataFormatUtils.hexStr2Bytes(\r\n                    \"00\" + data.substring(\r\n                        22,\r\n                        24\r\n                    )\r\n                ),\r\n            )\r\n            Log.e(\"TAG11\", \"当前的按压值$L_d1  $L_d2  $L_d3\")\r\n            Log.e(\"TAG11\", \"当前的吹气值$QY_d1  $QY_d2  $QY_d3\")\r\n            //判断是按压还是吹气，执行相应的动作\r\n            /*\r\n            * 吹气状态的判断：\r\n            * 1：当三个值均为0，代表完成一次按压；\r\n            * 2：当有一个值小于5也默认完成一次按压\r\n            * */\r\n            if (selectMax(QY_d1, QY_d2, QY_d3) > 10) {\r\n                QY_RUN_FLAG = 1\r\n            } else {\r\n                QY_Value = 0\r\n            }\r\n            if (QY_RUN_FLAG == 1) {\r\n                Log.e(\"TAG11\", \"判断为吹气状态\")\r\n                QY_Value = selectValue_QY(QY_d1, QY_d2, QY_d3)\r\n            } else {\r\n                //吹气数据\r\n                Log.e(\"TAG11\", \"判断为按压状态\")\r\n                L_Value = selectValue_P(L_d1, L_d2, L_d3)\r\n                //清空频率\r\n                pt(L_Value)\r\n            }\r\n            py(QY_Value)\r\n            //频率\r\n            // var pfvalue=DataFormatUtils.byteArrayToInt( DataFormatUtils.hexStr2Bytes(\"00\" + data.substring(24, 26)));\r\n            // Log.e(\"TAG9\", \"按压频率：$pfvalue\")\r\n            // CF_Value=DataFormatUtils.byteArrayToInt( DataFormatUtils.hexStr2Bytes(\"00\" + data.substring(26, 28)));\r\n            var v = DataFormatUtils.byteArrayToInt(\r\n                DataFormatUtils.hexStr2Bytes(\r\n                    \"00\" + data.substring(\r\n                        30,\r\n                        32\r\n                    )\r\n                )\r\n            )\r\n            if (abs(v - VI_Value) > 5) {\r\n                if (v < 5) {\r\n                    VI_Value = 5\r\n                } else if (v > 95) {\r\n                    VI_Value = 100\r\n                } else {\r\n                    VI_Value = (v / 5).toInt() * 5\r\n                }\r\n            }\r\n\r\n        }\r\n        val stringBuffer = StringBuffer()\r\n        stringBuffer.append(\"电量值：\").append(VI_Value)\r\n        stringBuffer.append(\"距离值：\").append(L_Value)\r\n        stringBuffer.append(\"气压值：\").append(QY_Value)\r\n        stringBuffer.append(\"蓝牙连接值：\").append(BLS_Value)\r\n        stringBuffer.append(\"USB连接值：\").append(ULS_Value)\r\n        stringBuffer.append(\"通道打开状态值：\").append(TOS_Value)\r\n        stringBuffer.append(\"连接方式值：\").append(LKS_Value)\r\n        stringBuffer.append(\"按压位置正确值：\").append(PSR_Value)\r\n        stringBuffer.append(\"工作方式值：\").append(WS_Value)\r\n        stringBuffer.append(\"按压频率值：\").append(PF_Value)\r\n        stringBuffer.append(\"吹气频率值：\").append(CF_Value)\r\n\r\n        val dataDTO = BaseDataDTO()\r\n        dataDTO.mac = deviceMAC.toString()\r\n        dataDTO.prSum = PR_SUM\r\n        dataDTO.qySum = QY_SUM\r\n        dataDTO.electricity = VI_Value\r\n        dataDTO.distance = L_Value\r\n        dataDTO.bpValue = QY_Value\r\n        dataDTO.blsType = BLS_Value\r\n        dataDTO.usbConnectType = ULS_Value\r\n        dataDTO.aisleType = TOS_Value\r\n        dataDTO.connectType = LKS_Value\r\n        dataDTO.psrType = PSR_Value\r\n        dataDTO.workType = WS_Value\r\n        dataDTO.cf = CF_Value\r\n        dataDTO.pf = PF_Value\r\n        dataDTO.isStart = isStart\r\n        dataDTO.err_pr_high = ERR_PR_HIGH\r\n        dataDTO.err_pr_low = ERR_PR_LOW\r\n        dataDTO.err_qy_close = ERR_QY_CLOSE\r\n        dataDTO.err_pr_posi = ERR_PR_POSI\r\n        dataDTO.err_qy_dead = ERR_QY_DEAD\r\n        dataDTO.err_qy_high = ERR_QY_HIGH\r\n        dataDTO.err_qy_low = ERR_QY_LOW\r\n        dataDTO.err_pr_unback = ERR_PR_UNBACK\r\n        dataDTO.pr_depth_sum = PR_DEPTH_SUM  //按压深度总和(mm)\r\n        dataDTO.pr_time_sum = PR_TIME_SUM    // 按压时间总和（ms）\r\n        dataDTO.qy_volume_sum = QY_VOLUME_SUM  //吹气量总和\r\n        dataDTO.qy_time_sum = QY_TIME_SUM     //吹气时间总和\r\n        dataDTO.pr_seqright_total = PR_SEQRIGHT_TOTAL //按压频率正常的次数\r\n        dataDTO.qy_serright_total = QY_SERRIGHT_TOTAL //吹气频率正确的次数\r\n//        deviceMAC?.let { mapObject.put(it, dataDTO) }\r\n        dataDTO.preDistance = preDistance.toInt()\r\n        if (QY_SUM != qy) {\r\n            qy = QY_SUM\r\n            val max = qyMax()\r\n            dataDTO.qyValueSum = qyValue()\r\n            dataDTO.qyMaxValue = getQyMax(max)\r\n            QY_MAX_VOLUME_SUM += getQyMax(max)\r\n        }\r\n        dataDTO.qy_max_volume_sum = QY_MAX_VOLUME_SUM\r\n        dataDTO.PR_HIGH_VALUE = PR_HIGH_VALUE\r\n        dataDTO.PR_LOW_VALUE = PR_LOW_VALUE\r\n        return dataDTO\r\n    }\r\n\r\n    /**\r\n     * 吹气体积\r\n     */\r\n    private fun getQyMax(value: Int): Int {\r\n        var qy = 0\r\n        when {\r\n            value < 30 -> {\r\n                qy = abs(20 * value - 100)\r\n            }\r\n            value in 30..60 -> {\r\n                qy = abs((10.0f / 3.0f) * value + 400).toInt()\r\n            }\r\n            value in 60..105 -> {\r\n                qy = abs((40.0f / 3.0f) * value - 200).toInt()\r\n            }\r\n            value > 105 -> {\r\n                qy = 1200\r\n            }\r\n        }\r\n        return qy\r\n    }\r\n\r\n    private var qy = 0\r\n    fun dataClear() {\r\n        isStart = false\r\n        //电量值：  0-100%\r\n        VI_Value = 0\r\n        //距离值：  30-150\r\n        L_Value = 0\r\n        //气压值：  0-2000ml\r\n        QY_Value = 0\r\n        //蓝牙连接状态：   0-断开 1-连接\r\n        BLS_Value = 0\r\n        //按压频率：0-200\r\n        PF_Value = 0\r\n        //吹气频率：0-200\r\n        CF_Value = 0\r\n        //按压次数\r\n        PR_SUM = 0\r\n        //吹气次数\r\n        QY_SUM = 0\r\n        ERR_PR_UNBACK = 0\r\n        ERR_PR_HIGH = 0\r\n        ERR_PR_LOW = 0\r\n        ERR_PR_POSI = 0\r\n        ERR_QY_CLOSE = 0\r\n        ERR_QY_DEAD = 0\r\n        ERR_QY_HIGH = 0\r\n        ERR_QY_LOW = 0\r\n        PR_DEPTH_SUM = 0  //按压深度总和(mm)\r\n        PR_TIME_SUM = 0    // 按压时间总和（ms）\r\n        QY_VOLUME_SUM = 0  //吹气量总和\r\n        QY_TIME_SUM = 0     //吹气时间总和\r\n        QY_MAX_VOLUME_SUM = 0//吹气每次最大值总和\r\n        PR_SEQRIGHT_TOTAL = 0; //按压频率正常的次数\r\n        QY_SERRIGHT_TOTAL = 0; //吹气频率正确的次数\r\n        L_valueSet.clear()\r\n        QY_valueSet.clear()\r\n        QY_valueSet2.clear()\r\n        py_valueSet.clear()\r\n        pt_valueSet.clear()\r\n    }\r\n    /*\r\n* 获取初始位置，每次连接成功后调用一次初始化方法\r\n* */\r\n\r\n    var preDistance: Long = 180\r\n\r\n    var preDistanceMap = mutableMapOf<String, Long>()\r\n\r\n    @Synchronized\r\n    fun initPreDistance(data: String?, macAddress: String) {\r\n        // long value=180;\r\n        if (data != null && data.length == 40) {\r\n            //按压距离\r\n            val L_d1 = DataFormatUtils.byteArrayToInt(\r\n                DataFormatUtils.hexStr2Bytes(\r\n                    \"00\" + data.substring(\r\n                        12,\r\n                        14\r\n                    )\r\n                )\r\n            )\r\n            val L_d2 = DataFormatUtils.byteArrayToInt(\r\n                DataFormatUtils.hexStr2Bytes(\r\n                    \"00\" + data.substring(\r\n                        14,\r\n                        16\r\n                    )\r\n                )\r\n            )\r\n            val L_d3 = DataFormatUtils.byteArrayToInt(\r\n                DataFormatUtils.hexStr2Bytes(\r\n                    \"00\" + data.substring(\r\n                        16,\r\n                        18\r\n                    )\r\n                )\r\n            )\r\n            preDistance = ((L_d1 + L_d2 + L_d3) / 3).toLong();\r\n            //preDistance=150\r\n            // preDistance=L_d1.toLong();\r\n            macAddress.let {\r\n                preDistanceMap[macAddress] = preDistance\r\n            }\r\n        }\r\n    }\r\n\r\n    private var UNBACK_FLAG = 0\r\n    private var ERR_FLAG = 0\r\n    private var PR_DOTTIMSE_NUMBER = 0\r\n    private var PR_RUN_FLAG = 0\r\n    private var MIN_FLAG = 0;\r\n\r\n    private var PR_DEPTH_SUM = 0  //按压深度总和(mm)\r\n    private var PR_TIME_SUM = 0    // 按压时间总和（ms）\r\n    private var QY_VOLUME_SUM = 0  //吹气量总和\r\n    private var QY_MAX_VOLUME_SUM = 0 //每次吹气峰值总和\r\n    private var QY_TIME_SUM = 0     //吹气时间总和\r\n    private var PR_SEQRIGHT_TOTAL = 0; //按压频率正常的次数\r\n    private var QY_SERRIGHT_TOTAL = 0; //吹气频率正确的次数\r\n    private  var L_compare=0;//距离参考值，记录上次的有效值\r\n\r\n    /*\r\n    * 根据按压三次相邻的距离值找到有效值。\r\n    * */\r\n    private fun selectValue_P(L_d1: Int, L_d2: Int, L_d3: Int): Int {\r\n        var value = 0\r\n        var index = 0\r\n        Log.e(\"TAG8\", \"$L_d1  $L_d2  $L_d3\")\r\n        if (PR_RUN_FLAG == 1) {\r\n            L_valueSet.add(index, L_d1)\r\n            L_valueSet.add(index + 1, L_d2)\r\n            L_valueSet.add(index + 2, L_d3)\r\n            index += 3\r\n        }\r\n        //消除传感器自身的波动误差\r\n        if (abs(preDistance - L_d1) < 10 && abs(preDistance - L_d2) < 10 && abs(preDistance - L_d3) < 10\r\n        ) {\r\n            low_flag = 0\r\n            UNBACK_FLAG = 0\r\n            return preDistance.toInt()\r\n        }\r\n        if(QY_CYCLE_TIMES<QY_DEFAULT_TIMES&&QY_CYCLE_TIMES>0){\r\n            QY_TIMES_TOOLITTLE=QY_DEFAULT_TIMES-QY_CYCLE_TIMES\r\n            QY_CYCLE_TIMES=0\r\n        }else{\r\n            QY_CYCLE_TIMES=0\r\n        }\r\n\r\n        // int low_flag=0;\r\n        if (L_d1 >= L_d2) {\r\n            //  PR_DOTTIMSE_NUMBER+=3\r\n            if (L_d2 >= L_d3) {\r\n                if (selectMax(abs(L_d1 - L_d2), abs(L_d1 - L_d3), abs(L_d2 - L_d3)) > 5) {\r\n                    low_flag = 0\r\n                    if (UNBACK_FLAG == 1) {\r\n                        ERR_PR_UNBACK++\r\n                        UNBACK_FLAG = 0\r\n                        Log.e(\"TAG12\", \"按压未回弹\")\r\n                        ERR_FLAG = 1;\r\n\r\n                    }\r\n                }\r\n                value = L_d3\r\n            } else {\r\n                if (selectMax(abs(L_d1 - L_d2), abs(L_d1 - L_d3), abs(L_d2 - L_d3)) > 5) {\r\n                    //当最低点距离小于30时不作为按压一次处理\r\n                    if (preDistance - L_d2 < 30) {\r\n                        return L_d2\r\n                    }\r\n                    if (low_flag == 0) {//防止在上升到最高点出现抖动导致次数误增加\r\n                        low_flag = 1\r\n                        PR_SUM++\r\n                        PR_CYCLE_TIMES++\r\n                        //  Log.e(\"TAG5\", \"$PR_SUM\")\r\n                        if (ERR_FLAG == 0) {\r\n                            Err_PrTotal(L_d2)\r\n                        } else {\r\n                            ERR_FLAG = 0;\r\n                        }\r\n                        PR_RUN_FLAG = 1;\r\n                        //  Log.e(\"TAG8\", \"距离点数$PR_DOTTIMSE_NUMBER\")\r\n                        if (PR_SUM > 1) {\r\n                            if (L_valueSet.size > 30) {\r\n                                PF_Value = 0;\r\n                                L_valueSet.clear()\r\n                            } else {\r\n                                if (MIN_FLAG == 1) {\r\n                                    PR_DOTTIMSE_NUMBER = L_valueSet.size\r\n                                } else if (MIN_FLAG == 2) {\r\n                                    PR_DOTTIMSE_NUMBER = L_valueSet.size + 2\r\n                                }\r\n                                PR_TIME_SUM += (PR_DOTTIMSE_NUMBER * 40).toInt()\r\n                                PF_Value =\r\n                                    (PF_Value + (60000 / (PR_DOTTIMSE_NUMBER * 40)).toInt()) / 2\r\n                                if (PF_Value in 100..120) {\r\n                                    PR_SEQRIGHT_TOTAL++\r\n                                }\r\n                                PR_DOTTIMSE_NUMBER = 0;\r\n                                index = 0\r\n                                L_valueSet.clear()\r\n                            }\r\n                            PR_DEPTH_SUM += (preDistance - L_d2 + 5).toInt()\r\n\r\n                        }\r\n\r\n                    }\r\n                    MIN_FLAG = 1\r\n                }\r\n                value = L_d2\r\n            }\r\n        } else if (L_d2 < L_d3) {\r\n            if (selectMax(abs(L_d1 - L_d2), abs(L_d1 - L_d3), abs(L_d2 - L_d3)) > 5) {\r\n                // PR_DOTTIMSE_NUMBER+=3\r\n                if (preDistance - L_d1 < 30) {\r\n                    return L_d1\r\n                }\r\n                /* if(abs(L_d2-L_d1)<15&&abs(L_d3-L_d2)<15&&abs(L_d3-L_d1)<15){\r\n                return L_d1\r\n            }*/\r\n                if (low_flag == 0) {\r\n                    low_flag = 1\r\n\r\n                    PR_SUM++\r\n                    PR_CYCLE_TIMES++\r\n                    // Log.e(\"TAG5\", \"$PR_SUM\")\r\n                    if (ERR_FLAG == 0) {\r\n                        if(L_compare<L_d1){\r\n                            Err_PrTotal(L_compare)\r\n                        }else{\r\n                            Err_PrTotal(L_d1)\r\n                        }\r\n                    } else {\r\n                        ERR_FLAG = 0;\r\n                    }\r\n                    PR_RUN_FLAG = 1;\r\n                    //Log.e(\"TAG8\", \"距离点数$PR_DOTTIMSE_NUMBER\")\r\n                    if (PR_SUM > 1) {\r\n                        if (L_valueSet.size > 30) {\r\n                            PF_Value = 0;\r\n                            L_valueSet.clear()\r\n                        } else {\r\n                            if (MIN_FLAG == 1) {\r\n                                PR_DOTTIMSE_NUMBER = L_valueSet.size - 2\r\n                            } else if (MIN_FLAG == 2) {\r\n                                PR_DOTTIMSE_NUMBER = L_valueSet.size\r\n                            }\r\n                            PR_TIME_SUM += (PR_DOTTIMSE_NUMBER * 40).toInt()\r\n                            PF_Value = (PF_Value + (60000 / (PR_DOTTIMSE_NUMBER * 40)).toInt()) / 2\r\n                            if (PF_Value in 100..120) {\r\n                                PR_SEQRIGHT_TOTAL++\r\n                            }\r\n                            PR_DOTTIMSE_NUMBER = 0;\r\n                            index = 0\r\n                            L_valueSet.clear()\r\n                        }\r\n                        PR_DEPTH_SUM += (preDistance - L_d1 + 5).toInt()\r\n                    }\r\n                    MIN_FLAG = 2\r\n                    value = L_d1\r\n                } else {\r\n                    // PR_DOTTIMSE_NUMBER+=3\r\n                    Log.e(\"TAG7\", \"初始位置$preDistance\")\r\n                    if (abs(preDistance - L_d3) < 12) {\r\n                        UNBACK_FLAG = 0\r\n                        low_flag = 0\r\n                        //Log.e(\"TAG7\", \"初始位置$preDistance\")\r\n                        // Log.e(\"TAG7\", \"回到初始位置，复位$L_d3\")\r\n                    } else {\r\n                        UNBACK_FLAG = 1\r\n                        //  Log.e(\"TAG7\", \"未回弹$L_d3\")\r\n                    }\r\n                    value = L_d3\r\n                }\r\n            }\r\n            value = L_d2\r\n        } else {\r\n            if (selectMax(abs(L_d1 - L_d2), abs(L_d1 - L_d3), abs(L_d2 - L_d3)) > 5) {\r\n                // PR_DOTTIMSE_NUMBER+=3\r\n                Log.e(\"TAG7\", \"初始位置$preDistance\")\r\n                if (abs(preDistance - L_d2) < 12) {\r\n                    UNBACK_FLAG = 0\r\n                    Log.e(\"TAG7\", \"回到初始位置，复位未回弹$L_d2\")\r\n                    low_flag = 0\r\n                } else {\r\n                    UNBACK_FLAG = 1\r\n                    Log.e(\"TAG7\", \"未回弹$L_d2\")\r\n                }\r\n            }\r\n            value = L_d2\r\n        }\r\n        L_compare=value\r\n        return value\r\n    }\r\n\r\n    //按压错误-按压未回弹\r\n    private var ERR_PR_UNBACK = 0\r\n\r\n    //按压错误-按压不足\r\n    private var ERR_PR_LOW = 0\r\n\r\n    //按压错误-按压过大\r\n    private var ERR_PR_HIGH = 0\r\n\r\n    //按压错误-按压位置错误\r\n    private var ERR_PR_POSI = 0\r\n\r\n    //按压超次\r\n    private var ERR_PR_TOOMORE=0\r\n    //按压少次\r\n    private var ERR_PR_TOOLITTLE=0\r\n    //默认单次按压循环的次数是30\r\n    private var PR_DEFAULT_TIMES=30;\r\n    //单次按压循环的次数\r\n    private var PR_CYCLE_TIMES=0;\r\n\r\n    private fun Err_PrTotal(l: Int) {\r\n        if(PR_CYCLE_TIMES>PR_DEFAULT_TIMES) {\r\n            ERR_PR_TOOMORE++\r\n        }else {\r\n            if (PSR_Value == 0) {\r\n                ERR_PR_POSI++\r\n                Log.e(\"TAG11\", \"按压位置错误\")\r\n            } else {\r\n                var value = abs(preDistance - l)\r\n                if (value < PR_LOW_VALUE) {\r\n                    ERR_PR_LOW++\r\n                    Log.e(\"TAG11\", \"$PR_LOW_VALUE\")\r\n                    Log.e(\"TAG11\", \"按压不足\")\r\n                    Log.e(\"TAG11\", \"$value\")\r\n                } else if (value > PR_HIGH_VALUE) {\r\n                    ERR_PR_HIGH++\r\n                    Log.e(\"TAG11\", \"$PR_HIGH_VALUE\")\r\n                    Log.e(\"TAG11\", \"按压过深\")\r\n                    Log.e(\"TAG11\", \"$value\")\r\n                }\r\n                // Log.e(\"TAG3\", \"$value\")\r\n            }\r\n        }\r\n    }\r\n\r\n    //吹气错误-气压不足\r\n    private var ERR_QY_LOW = 0\r\n\r\n    //吹气错误-气压过大\r\n    private var ERR_QY_HIGH = 0\r\n\r\n    //吹气错误-气压进胃\r\n    private var ERR_QY_DEAD = 0\r\n\r\n    //吹气错误-气道未打开错误\r\n    private var ERR_QY_CLOSE = 0\r\n\r\n    //默认单次循环吹气次数\r\n    private var QY_DEFAULT_TIMES=2\r\n    //单次循环吹气次数\r\n    private var QY_CYCLE_TIMES=0;\r\n    //吹气超次\r\n    private var QY_TIMES_TOOMORE=0\r\n    //吹气少次\r\n    private var QY_TIMES_TOOLITTLE=0;\r\n\r\n    private fun ERR_QyTotal(value: Int) {\r\n        if(QY_CYCLE_TIMES>QY_DEFAULT_TIMES){\r\n            QY_TIMES_TOOMORE++\r\n        }else {\r\n            if (TOS_Value == 0) {\r\n                ERR_QY_CLOSE++\r\n            } else {\r\n                when {\r\n                    value < QY_LOW_VALUE -> {\r\n                        ERR_QY_LOW++\r\n                    }\r\n                    value in QY_HIGH_VALUE..1199 -> {\r\n                        ERR_QY_HIGH++\r\n                    }\r\n                    value >= 1200 -> {\r\n                        ERR_QY_DEAD++\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private var preTimeQY: Long = 0\r\n\r\n    /*\r\n * 根据吹气三次相邻的气压值找到有效值。\r\n * */\r\n    private fun selectValue_QY(QY_d1: Int, QY_d2: Int, QY_d3: Int): Int {\r\n        var value = 0\r\n        if (QY_d1 > 5 || QY_d2 > 5 || QY_d3 > 5) {\r\n            top_flag = 1\r\n            Qliang = (QY_d1 + QY_d2 + QY_d3) * 30\r\n            QY_VOLUME_SUM += Qliang\r\n            if(PR_CYCLE_TIMES<30&&PR_CYCLE_TIMES>0){\r\n                ERR_PR_TOOLITTLE+=(30-PR_CYCLE_TIMES)\r\n            }\r\n            PR_CYCLE_TIMES=0\r\n        }\r\n        if (QY_d1 <= 5 && QY_d2 <= 5 && QY_d3 <= 5) {\r\n            QY_RUN_FLAG = 0\r\n            if (top_flag == 1) {\r\n\r\n                val changTimePress = System.currentTimeMillis()\r\n                ++QY_SUM\r\n                QY_CYCLE_TIMES++\r\n                ERR_QyTotal(getQyMax(max(true)))//每次筛选最大吹气值，去做错误次数的判断\r\n                top_flag = 0\r\n                Qliang = 0\r\n                if (QY_SUM > 1) {\r\n                    val time = changTimePress - preTimeQY\r\n                    QY_TIME_SUM += time.toInt()\r\n                    CF_Value = (60000 / time).toInt()\r\n                    if (CF_Value in 6..8) {\r\n                        QY_SERRIGHT_TOTAL++\r\n                    }\r\n                }\r\n                preTimeQY = changTimePress\r\n                // Log.e(\"TAG10\", \"吹气的时间累加和$QY_TIME_SUM\")\r\n            } else {\r\n                return 0\r\n            }\r\n        }\r\n        value = if (QY_d1 <= QY_d2) {\r\n            if (QY_d2 <= QY_d3) {\r\n                QY_d3\r\n            } else {\r\n                //  top_flag=1;\r\n                QY_d2\r\n            }\r\n        } else {\r\n            if (QY_d2 >= QY_d3) {\r\n                QY_d3\r\n            } else {\r\n                QY_d2\r\n            }\r\n        }\r\n        if (value > 0) {\r\n            QY_valueSet2.add(value)\r\n            QY_valueSet.add(value)\r\n            QY_valueSet3.add(value)\r\n        }\r\n        return value\r\n    }\r\n\r\n    //判断按压是否停止\r\n    private val count = 20\r\n    private fun pt(p: Int): Boolean {\r\n        if (p > (preDistance - 5)) {\r\n            if (pt_valueSet.size == count) pt_valueSet.removeFirst()\r\n            pt_valueSet.add(p)\r\n            if (pt_valueSet.size == count) {\r\n                pt_valueSet.clear()\r\n                PF_Value = 0\r\n                return true\r\n            }\r\n        } else {\r\n            pt_valueSet.clear()\r\n        }\r\n        return false\r\n    }\r\n\r\n    //判断按压是否停止\r\n    private fun py(p: Int): Boolean {\r\n        if (p == 0) {\r\n            if (py_valueSet.size == count) py_valueSet.removeFirst()\r\n            py_valueSet.add(p)\r\n            if (py_valueSet.size == count) {\r\n                py_valueSet.clear()\r\n                CF_Value = 0\r\n                return true\r\n            }\r\n        } else {\r\n            py_valueSet.clear()\r\n        }\r\n        return false\r\n    }\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/pr/perfectrecovery/utils/DataVolatile.kt b/app/src/main/java/com/pr/perfectrecovery/utils/DataVolatile.kt
--- a/app/src/main/java/com/pr/perfectrecovery/utils/DataVolatile.kt	
+++ b/app/src/main/java/com/pr/perfectrecovery/utils/DataVolatile.kt	
@@ -16,6 +16,11 @@
 
         var QY_LOW_VALUE = 35
         var QY_HIGH_VALUE = 50
+
+        //默认单次按压循环的次数是30
+        var PR_DEFAULT_TIMES = 30
+        //默认单次循环吹气次数
+        var QY_DEFAULT_TIMES = 2
     }
 
     //电量值：  0-100%
@@ -462,7 +467,7 @@
     private var QY_TIME_SUM = 0     //吹气时间总和
     private var PR_SEQRIGHT_TOTAL = 0; //按压频率正常的次数
     private var QY_SERRIGHT_TOTAL = 0; //吹气频率正确的次数
-    private  var L_compare=0;//距离参考值，记录上次的有效值
+    private var L_compare = 0;//距离参考值，记录上次的有效值
 
     /*
     * 根据按压三次相邻的距离值找到有效值。
@@ -484,11 +489,11 @@
             UNBACK_FLAG = 0
             return preDistance.toInt()
         }
-        if(QY_CYCLE_TIMES<QY_DEFAULT_TIMES&&QY_CYCLE_TIMES>0){
-            QY_TIMES_TOOLITTLE=QY_DEFAULT_TIMES-QY_CYCLE_TIMES
-            QY_CYCLE_TIMES=0
-        }else{
-            QY_CYCLE_TIMES=0
+        if (QY_CYCLE_TIMES < QY_DEFAULT_TIMES && QY_CYCLE_TIMES > 0) {
+            QY_TIMES_TOOLITTLE = QY_DEFAULT_TIMES - QY_CYCLE_TIMES
+            QY_CYCLE_TIMES = 0
+        } else {
+            QY_CYCLE_TIMES = 0
         }
 
         // int low_flag=0;
@@ -569,9 +574,9 @@
                     PR_CYCLE_TIMES++
                     // Log.e("TAG5", "$PR_SUM")
                     if (ERR_FLAG == 0) {
-                        if(L_compare<L_d1){
+                        if (L_compare < L_d1) {
                             Err_PrTotal(L_compare)
-                        }else{
+                        } else {
                             Err_PrTotal(L_d1)
                         }
                     } else {
@@ -633,7 +638,7 @@
             }
             value = L_d2
         }
-        L_compare=value
+        L_compare = value
         return value
     }
 
@@ -650,23 +655,23 @@
     private var ERR_PR_POSI = 0
 
     //按压超次
-    private var ERR_PR_TOOMORE=0
+    private var ERR_PR_TOOMORE = 0
+
     //按压少次
-    private var ERR_PR_TOOLITTLE=0
-    //默认单次按压循环的次数是30
-    private var PR_DEFAULT_TIMES=30;
+    private var ERR_PR_TOOLITTLE = 0
+
     //单次按压循环的次数
-    private var PR_CYCLE_TIMES=0;
+    private var PR_CYCLE_TIMES = 0
 
     private fun Err_PrTotal(l: Int) {
-        if(PR_CYCLE_TIMES>PR_DEFAULT_TIMES) {
+        if (PR_CYCLE_TIMES > PR_DEFAULT_TIMES) {
             ERR_PR_TOOMORE++
-        }else {
+        } else {
             if (PSR_Value == 0) {
                 ERR_PR_POSI++
                 Log.e("TAG11", "按压位置错误")
             } else {
-                var value = abs(preDistance - l)
+                val value = abs(preDistance - l)
                 if (value < PR_LOW_VALUE) {
                     ERR_PR_LOW++
                     Log.e("TAG11", "$PR_LOW_VALUE")
@@ -695,19 +700,19 @@
     //吹气错误-气道未打开错误
     private var ERR_QY_CLOSE = 0
 
-    //默认单次循环吹气次数
-    private var QY_DEFAULT_TIMES=2
     //单次循环吹气次数
-    private var QY_CYCLE_TIMES=0;
+    private var QY_CYCLE_TIMES = 0;
+
     //吹气超次
-    private var QY_TIMES_TOOMORE=0
+    private var QY_TIMES_TOOMORE = 0
+
     //吹气少次
-    private var QY_TIMES_TOOLITTLE=0;
+    private var QY_TIMES_TOOLITTLE = 0;
 
     private fun ERR_QyTotal(value: Int) {
-        if(QY_CYCLE_TIMES>QY_DEFAULT_TIMES){
+        if (QY_CYCLE_TIMES > QY_DEFAULT_TIMES) {
             QY_TIMES_TOOMORE++
-        }else {
+        } else {
             if (TOS_Value == 0) {
                 ERR_QY_CLOSE++
             } else {
@@ -737,10 +742,10 @@
             top_flag = 1
             Qliang = (QY_d1 + QY_d2 + QY_d3) * 30
             QY_VOLUME_SUM += Qliang
-            if(PR_CYCLE_TIMES<30&&PR_CYCLE_TIMES>0){
-                ERR_PR_TOOLITTLE+=(30-PR_CYCLE_TIMES)
+            if (PR_CYCLE_TIMES < 30 && PR_CYCLE_TIMES > 0) {
+                ERR_PR_TOOLITTLE += (30 - PR_CYCLE_TIMES)
             }
-            PR_CYCLE_TIMES=0
+            PR_CYCLE_TIMES = 0
         }
         if (QY_d1 <= 5 && QY_d2 <= 5 && QY_d3 <= 5) {
             QY_RUN_FLAG = 0
